COPY THIS ENTIRE MESSAGE AND PASTE INTO A NEW CHAT TO START MODULE 1 IMPLEMENTATION
==================================================================================

I need you to implement Module 1 (Platform.Core - Context Abstractions) for a Senior Living Platform using .NET 10, following strict TDD practices.

CRITICAL RULES:
1. DO NOT ASSUME SUCCESS - RELY ON PASSED TESTS
2. Write failing tests FIRST (RED)
3. Implement minimum code to pass (GREEN)
4. Refactor while keeping tests green (REFACTOR)
5. Use real dependencies via Testcontainers for integration tests
6. Do NOT mark complete until ALL tests pass (100%)

CONTEXT:
- Project root: SeniorLivingPlatform/
- Module location: src/Platform.Core/
- Test location: tests/Platform.Core.Tests/
- .NET 10, C# latest
- Testing: xUnit, FluentAssertions, NSubstitute
- No external dependencies for this module (foundation module)

BACKGROUND:
This is a multi-tenant senior living platform migration from .NET Framework to .NET 10. We're building a modular monolith with proper abstractions for multi-tenancy. Module 1 creates the foundation context abstractions that all other modules will depend on.

KEY CONCEPTS:
- Company: Tenant organization (e.g., "Sunrise Senior Living")
- Facility: Physical location (e.g., "Sunrise of Arlington")
- Multi-tenancy: Every query filtered by CompanyId + FacilityId
- Context: Abstraction providing current request scope (company, facility, etc.)

MODULE SPECIFICATION:

## Module Purpose
Create focused context abstractions for multi-tenancy. Instead of one monolithic ITenantContext, we compose small, single-responsibility interfaces:
- ICompanyContext → Which company is this request for?
- IFacilityContext → Which facility is the user working in?
- IDatabaseContext → Which database should I query?
- IStorageContext → Where should I store files?
- ICacheContext → What cache key prefix?
- IMessagingContext → How to tag messages?
- IObservabilityContext → How to enrich traces/logs?

## Must-Have Features

F1: Company Context Abstraction
- Resolve company from subdomain (e.g., acme.platform.com → Company "Acme")
- Resolve company from JWT claims (for API requests)
- Provide CompanyId, CompanyName, Tier
- Thread-safe via AsyncLocal<T>
- Fail-fast if context missing (throw exception)

F2: Facility Context Abstraction
- Track active facility for user
- Support "All Facilities" mode (nullable ActiveFacilityId)
- Provide list of accessible facilities
- Switch facility with validation

F3: Database Context Abstraction
- Determine database connection for company
- Support read replica routing
- Connection strings for Admin, Tenant, Families, Cosmos DBs

F4: Storage Context Abstraction
- Tenant-prefixed blob paths: {company}/{facility}/{fileName}
- Generate SAS URLs with expiry
- Support local file system for dev

F5: Cache Context Abstraction
- Tenant-prefixed keys: {companyId}:{facilityId}:{key}
- Prevent cross-tenant cache pollution
- Cache invalidation by tenant

F6: Messaging Context Abstraction
- Tag messages with CompanyId + FacilityId
- Envelope pattern for reliable context propagation
- Prevent cross-tenant message leaking

F7: Observability Context Abstraction
- Inject tenant info into traces (OpenTelemetry baggage)
- Enrich logs with structured fields
- Metrics with tenant dimensions

F8: Context Composition
- All contexts injectable independently
- No God objects
- Testable via interface mocking

## Constraints

C1: Thread Safety - Use AsyncLocal<T> for context storage (not ThreadLocal)
C2: Fail-Fast - Throw exception if context missing (don't return null/corrupt data)
C3: Performance - Context resolution < 1ms
C4: Testing - All interfaces must be mockable
C5: Extensibility - Open/closed principle

## TDD Use Cases (Implement in This Order)

UC1.1: Resolve Company from Subdomain
- Write failing test: Mock HttpContext with Host = "acme.platform.com"
- Implement ICompanyContext interface
- Implement CompanyContextMiddleware
- Make test pass
- Integration test: Real request via TestServer

UC1.2: Resolve Company from JWT Claims
- Write failing test: Mock ClaimsPrincipal with companyId claim
- Extend middleware to handle claims
- Make test pass
- Integration test: Real JWT validation

UC1.3: Switch Facility
- Write failing test: User switches to accessible facility
- Implement IFacilityContext.SwitchFacility()
- Make test pass
- Integration test: Verify session persistence

UC1.4: All Facilities Mode
- Write failing test: ActiveFacilityId = null filters by accessible facilities
- Implement "All Facilities" query logic
- Make test pass
- Integration test: Verify correct filtering

UC1.5: Storage Path Prefixing
- Write failing test: Verify path format {company}/{facility}/{file}
- Implement IStorageContext.GetBlobPath()
- Make test pass
- Integration test: Path sanitization (no ../ attacks)

UC1.6: Cache Key Prefixing
- Write failing test: Verify key format {companyId}:{facilityId}:{key}
- Implement ICacheContext.GetCacheKey()
- Make test pass
- Integration test: Verify no key collisions across tenants

UC1.7: Message Tenant Tagging
- Write failing test: Verify envelope has CompanyId + FacilityId
- Implement IMessagingContext and envelope pattern
- Make test pass
- Integration test: Publish/consume with context restoration

UC1.8: Observability Enrichment
- Write failing test: Verify log has companyId/facilityId fields
- Implement IObservabilityContext
- Make test pass
- Integration test: Verify trace tags present

## TASK FOR YOU (AI Agent)

Implement all 8 use cases using strict TDD:

FOR EACH USE CASE:
1. Create test file (if doesn't exist)
2. Write [Fact] test method that describes expected behavior
3. Run: dotnet test --filter "TestMethodName"
4. Verify test FAILS (RED) - Show me the failure
5. Implement minimum code in src/Platform.Core/
6. Run: dotnet test --filter "TestMethodName"
7. Verify test PASSES (GREEN) - Show me the success
8. Refactor if needed (keep tests green)
9. Write integration test with real dependencies
10. Run integration test, verify PASSES
11. Move to next use case

DELIVERABLES:
- ICompanyContext interface
- IFacilityContext interface
- IDatabaseContext interface
- IStorageContext interface
- ICacheContext interface
- IMessagingContext interface
- IObservabilityContext interface
- CompanyContextMiddleware (resolves from subdomain and claims)
- All unit tests (minimum 24 tests for 8 use cases)
- All integration tests
- README.md with usage examples
- XML comments on all public APIs

COMPLETION CRITERIA:
Run these commands and show me results:
```bash
dotnet test --filter "Module=PlatformCore"
# Expected: All tests passing (100%)

dotnet test --filter "Module=PlatformCore&Category=Integration"
# Expected: All integration tests passing

dotnet build --warnaserror
# Expected: No warnings
```

START WITH UC1.1 (Resolve Company from Subdomain):
1. Show me the failing test code
2. Show me the implementation code (interface + middleware)
3. Show me the test passing

Then continue to UC1.2, UC1.3, etc., showing test results at EVERY step.

DO NOT SKIP AHEAD. DO NOT ASSUME SUCCESS. SHOW ME PASSING TESTS.

Ready? Start with UC1.1 now.
